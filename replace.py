import os
import numpy as np
import sys
import re
import time
import math
import argparse
##!!python replace filename.vasp mode 0 0  ##for a single sub
##!!python replace filename.vasp mode 1 4  ##muti sub for files named filename-1.vasp to filename-4.vasp

#in this script,you don't need to copy a jobscript,what you need to do is PREPARE only TWO FILES!

##File prepare:
#1.prepare mode file and name as"in_scf" or "in_bands" and so on in current dir(you dont need to worry about the "nat" or "ntyp" or "nbnd" or "ATOMIC_SPECIES" or "CELL_PARAMETER" or "ATOMIC_POSITION",replace.py will calculate that for you)
#2.prepare the vasp file name end with ".vasp" and shall be fractional

##Functions:
#1.Auto_psp_copy:change the content in *sp_format* below for your psuedo potential, they will be copied from open/psp/
#2.Auto_atomic_layer_fixed:change the fixed atom layer by *upper_layer* and *bottom_layer*
#3.Switching flat:you can sub on different computational node only change "flat_number" below

##Others:
#1.Use run-all.py mode for sub all .vasp file in current dir
#2.Use read_relax_E.py for reading all Energies in current dir and also for a continuos calculation based on Prof.Zhengfan's bcon.sh scripts(bcon.sh shall be copy to your ~/bin/. command:cp /hpc/data/home/spst/zhengfan/open/bcon.sh ~/bin/.)
#3.Use read_qe_out_all.py for extrating all .xsf file from relax calculation in current dir base on Prof.Zhengfan's read_qeout_relax.py
#4.delelte the "delete_me_rm_file" file in dir generated by sripts if you want to start over

##SPIN and DFT+U:
#1.if use spin, the easiest way is set the spin down atom into another kind and edit the atomic species, for example, you wanna establish Ni1 and Ni2 whose spins is opposite, you can replace the Ni2 site with for example Au, and then close the vesta and open the vaspfile, reedit the Au into Ni2 and reedit the Ni into Ni1, then the program will read the diff and set the input for you.
#   And also make a new file named "SPIN" to specify the starting magnetization
#2. if use DFT+U,make a new file named "DFT-U" and settle the spin,notice the filename "SPIN" and "DFT-U" can be edit in the program

#if you want to sub script on computational node,set this to 1
sub_script=1

fixed_atom_mode=0   #turn this to 1 to fix atom and the atom fixed is set below:
upper_layer=0.14    #the upper of the fixed layer
down_layer=0.00      #the botton of the fixed layer
fixed_atom_index=[]

prefix="BTO"
spin_file="SPIN"   #the spin file
dftu_file="DFT-U"  #the DFT+U file
sp_format="X.SG15.PBE.UPF" #psp format psp_format_list=["X.SG15.LDA.UPF","X.SG15.PBE.UPF","X_frl_gga.upf","X_srl_gga.upf","ONCV.PWM.X.UPF","ONCV.PWM.X.IN"]
cnct_syb="-"           #the connected symbol of your file and the number,used in multi replace
bcon_mode=0            #when do relax and find some results not converge,open this and auto use bcon.sh
solvation_model=0     #solvation model
k_points_auto_mod=0    #automatic modify k_points
###################
qe_dir="/hpc/data/home/spst/zhengfan/open/replace"  #Your QE pw.x pp.x projwfc.x dir
psp_dir_root='/hpc/data/home/spst/xiety/bin/psp/'    #Your psuedo potential dir
psp_dir_backup='/hpc/data/home/spst/zhengfan/open/psp/' # Your psuedo potential backup dir 
JOB="xty_test"                                        #the jobscript name
qe_version="pw-6.8.x"        #This parameter was not used cuz the solvation model and the normal mode does not consistent

root_dir = os.path.expandvars('$HOME')
#code_dir="%s/bin/QE-batch"%root_dir
code_dir=sys.path[0]
####################above is what you need to change####################################
split_sybol_virtual="-" 

parser = argparse.ArgumentParser(description="This script is automatically convert the .vasp fractional file into a QE calculation directory, which is the main function of QE-batch, all you need is a input example file and a .vasp fractional file\n Run:\nPython {PATH to QE-batch}/QE-batch/replace xxx.vasp scf/relax/bands/pdos/BaderCharge")
parser.add_argument('vaspfile', type=str, help='The input .vasp fractional file name')
parser.add_argument("cal_mode", choices=["scf", "relax", "bands", "pdos", "BaderCharge"], help="The calculation mode: scf/relax/bands/pdos/BaderCharge")
parser.add_argument('batch_start_number', nargs='?', default=0, type=int, help='Optional,batch calculation start number,you will use \nPython {PATH to QE-batch}/QE-batch/replace xxx.vasp scf/relax/bands/pdos/BaderCharge {batch_start_number} {batch_end_number} to calculate xxx-{batch_start_number}.vasp xxx-{batch_start_number+1}.vasp .... xxx-{batch_end_number}.vasp\n But I suggest you just use \nPython QE-batch/run-all.py scf/relax/bands/pdos/BaderCharge instead') #nargs="?" suggest that it is a option
parser.add_argument('batch_end_number', nargs='?', default=0, type=int, help='Optional,batch calculation end number')
parser.add_argument('--no_submit', '-n', action='store_true', help='Add -d at end when you just do not want to submit job and only want to create the calculation directory')
# 解析命令行参数
args = parser.parse_args()



vaspfile=args.vaspfile

mode = args.cal_mode      #the mode of files you wanna input

error=0

if (mode!= "scf") & (mode!="surf") & (mode!="relax") & (mode!="bands") & (mode!="pdos") & (mode!="BaderCharge"):
    error=1 

molecule = vaspfile.split(".vasp")[0]            

input2 = ".vasp"

export_input_file="in_"+mode+"_"+molecule     #the name of files you wanna export

file_min=args.batch_start_number
file_max=args.batch_end_number                        #the minimun maximum number of your files

if args.no_submit:
    sub_script=0

#print(type(vaspfile),type(mode),type(file_min),type(file_max))
if os.path.isfile(f"{code_dir}/bcon.py")==1:
    print("bcon.py found")
    find_bcon=1
if find_bcon==0:
    print("bcon.py not found,plz download the full package of QE-batch!")

batch_mode=0

if file_min!=0:
    if file_max!=0:
        if file_min<file_max:
            batch_mode=1
        if file_min>file_max:
            error=1
            print("please check the min and max number!")
    if file_max==0:
        error=1
        print("please check the min and max number!")

elif file_min==0&file_max==0:
    error=0
    batch_mode=0
        
#print("batchmode:%d error:%d"%(batch_mode,error))


mode_name='in_'+mode

dir_file=(os.popen("pwd").read())
dir=max(dir_file.split('\n'))

input_cont=''


#jobscript_file.append("mpirun -np 64 pw.x -npool 2 -ndiag 64 < in_%s_%s  >& out_%s_%s"%(mode,molecule_i,mode,molecule_i))

def psp_dir(element_i):                                 #your psp dir should be add here
    psp_format_list=["X.SG15.LDA.UPF","X.SG15.PBE.UPF","X_frl_gga.upf","X_srl_gga.upf","ONCV.PWM.X.UPF","ONCV.PWM.X.IN"]
    psp_head_dir=psp_dir_root
    psp_head_zf_dir=psp_dir_backup
    psp_dir=["NCPP-SG15-LDA","NCPP-SG15-PBE","NC_psp","NC_psp","ONCV-PWM-PBE/%s"%(element_i),"ONCV-PWM-PBE/%s"%(element_i)]
    psp_abs_dir=psp_head_dir+psp_dir[psp_format_list.index(sp_format)]+"/"
    psp_abs_zf_dir=psp_head_zf_dir+psp_dir[psp_format_list.index(sp_format)]+"/"
    return [psp_abs_dir,psp_abs_zf_dir]

def spin_form(element_spin):
    return ''.join([i for i in element_spin if not i.isdigit()])

def psp_form(element_i):
    mixed_ele_spe=[]
    element_i_s=[x for x in element_i.split(split_sybol_virtual) if len(x)>0]
    for jj in element_i_s:
        if (element_i_s.index(jj) % 2) == 0:
            mixed_ele_spe.append(jj)
    if sp_format.find("rl_gga.upf")==-1:
        if split_sybol_virtual not in element_i:
            psp_out=sp_format.replace("X",spin_form(element_i))
        elif split_sybol_virtual in element_i:
            psp_out=sp_format.replace("X",(spin_form(mixed_ele_spe[0])+spin_form(mixed_ele_spe[1])))
    else:
        if split_sybol_virtual not in element_i:
            psp_out=sp_format.replace("X",(chr(ord(element_i[0])+32)+spin_form(element_i[1:])))
        elif split_sybol_virtual in element_i:
            psp_out=sp_format.replace("X",(spin_form(mixed_ele_spe[0])+spin_form(mixed_ele_spe[1])))
    return psp_out

def rl_aw(element_i):
    element=["H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Uun","Uuu","Uub"]   #end in 112
    atomic_weight=[1.01,4.00,6.94,9.01,10.81,12.01,14.01,16.00,19.00,20.17,22.99,24.31,26.98,28.09,30.97,32.06,35.45,39.94,39.10,40.08,44.96,47.9,50.94,52.00,54.94,55.84,58.93,58.69,63.54,65.38,69.72,72.5,74.92,78.9,79.90,83.8,85.47,87.62,88.91,91.22,92.91,95.94,99,101.07,102.91,106.42,107.87,112.41,114.82,118.6,121.7,127.6,126.91,131.3,132.91,137.33,138.91,140.12,140.91,144.2,147,150.4,151.96,157.25,158.93,162.5,164.93,167.2,168.93,173.0,174.96,178.4,180.95,183.8,186.21,190.2,192.2,195.08,196.97,200.5,204.3,207.2,208.98,209,201,222,223,226.03,227.03,232.04,231.04,238.03,237.05,244,243,247,247,251,254,257,258,259,260,261,262,263,262,265,266,269,272,277]
    if split_sybol_virtual not in element_i:
        return atomic_weight[element.index(''.join([i for i in element_i if not i.isdigit()]))]
    #create new element:
    if split_sybol_virtual in element_i:
        print("!!!  Virtual Crystal Approximation Detected  !!!")
        mixed_wt=0
        mixed_ele_spe=[]
        mixed_ele_wt=[]
        element_i_s=[x for x in element_i.split(split_sybol_virtual) if len(x)>0]
        for jj in element_i_s:
            if (element_i_s.index(jj) % 2) == 0:
                mixed_ele_spe.append(jj)
            elif (element_i_s.index(jj) % 2) == 1:
                mixed_ele_wt.append(jj)
        for ele_i in range(len(mixed_ele_spe)):
            mixed_wt+=atomic_weight[element.index(mixed_ele_spe[ele_i])]*float(mixed_ele_wt[ele_i])
     #generate new psp files:
        if os.path.isfile(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))==0:
            #print("creating %s..."%sp_format.replace("X",element_i.replace(".",split_sybol_virtual)))
            print("creating %s..."%sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))
            psp_dir1=psp_dir(mixed_ele_spe[0])[0]
            psp_dir2=psp_dir(mixed_ele_spe[0])[1]
            #print(psp_dir1,psp_dir2)
            if (os.path.isfile(psp_form(mixed_ele_spe[0])))&(os.path.isfile(psp_form(mixed_ele_spe[1]))):
                print("PSP file founded!")
            elif os.path.exists(psp_dir1):
                for ii in range(len(mixed_ele_spe)):
                    print("copy from root %s"%psp_form(mixed_ele_spe[ii]))
                    os.system("cp %s/%s ." %(psp_dir(mixed_ele_spe[ii])[0],psp_form(mixed_ele_spe[ii])))
            elif os.path.exists(psp_dir2):
                for ii in range(len(mixed_ele_spe)):
                    print("copy from zhengfan/open %s"%psp_form(mixed_ele_spe[ii]))
                    os.system("cp %s/%s ." %(psp_dir(mixed_ele_spe[ii])[1],psp_form(mixed_ele_spe[ii])))
            f_tem_psp=open("tem_psp","w")
            f_tem_psp.writelines(psp_form(mixed_ele_spe[0])+"\n")
            f_tem_psp.writelines(psp_form(mixed_ele_spe[1])+"\n")
            f_tem_psp.writelines(mixed_ele_wt[0]+"\n")
            f_tem_psp.close()
            print("mixing %s %s ..."%(psp_form(mixed_ele_spe[0]),psp_form(mixed_ele_spe[1])))
            jjj=os.popen("%s/virtual_v2.x < tem_psp"%code_dir).readlines()
            #os.system("mv NewPseudo.UPF %s"%(sp_format.replace("X",element_i.replace(".",split_sybol_virtual))))
            os.system("mv NewPseudo.UPF %s"%(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1]))))
        elif os.path.isfile(sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))==1:
            #print("%s detected!"%sp_format.replace("X",element_i.replace(".",split_sybol_virtual)))
            print("%s detected!"%sp_format.replace("X",(mixed_ele_spe[0]+mixed_ele_spe[1])))
        return float("%.2f"%mixed_wt) 
def read_vasp_single_file( filename ):
    with open(filename,'r') as f:
        raw = f.readlines()
    coorf = []; name = []; fix = []; lat = np.zeros( (3,3) )
    scale_factor = float(raw[1].split()[0])
    for order,i in enumerate(raw[2:5]):
        tmp_ = [float(j.strip().strip('\n')) for j in i.split()]
        lat[order,:] = np.array( tmp_ )
    name_set = raw[5].split()
#    for names_i in range(len(name_set)):
#        name_set[names_i]=name_set[names_i].replace(".","")
    name_count = [int(j) for j in raw[6].split()]
    name_count_spec = len(name_set)
    natom = sum( name_count )
    for iname in range(name_count_spec):
        for j in range(name_count[iname]):
            name.append( name_set[iname])
    for i in raw[8:natom+8]:
        tmp_ = [j.strip().strip('\n') for j in i.split()]
        tmp_2 = list(map(float, tmp_[0:3]))
        coorf.append( tmp_2 )
        coord = np.array(coorf)
    return np.array(name), lat, np.array(coord),natom,name_set


def bands_read(file_bands):
    bands_in_scf=[]
    readed=0
    f=open(file_bands,"r").readlines()
    for i in range(len(f)):
        if "occupation numbers" in f[i]:
            if readed==0:
                #print(i)
                for j in range(i+1,len(f)):
                    bands_line=f[j].split()
                    if len(bands_line)==0:
                        readed=1
                        break
                    elif len(bands_line)>0:
                        for k in bands_line:
                            if float(k)!=0:
                                bands_in_scf.append(k)
    bands_in_infile=int(len(bands_in_scf)*1.2)+1
    return bands_in_infile
#def print_func(name2,lat2,coord2,natom2):
#    print the way input file aquires
#    print("CELL_PARAMETERS {alat}",end='')
#    for i_cell_par in range(0,3):
#        print('')
#        print("   ",end='')
#        for j_cell_par in range(0,3):
#            print("%.10f"%lat2[i_cell_par][j_cell_par],end='')
#            print("      ",end='')
#    print('')
#    print("ATOMIC_POSITIONS (crystal)")
#    for i in range(natom2):
#        print("%s      %.9f     %.9f      %.9f "%(name2[i],coord2[i][0],coord2[i][1],coord2[i][2]),end='')
#        if(coord2[i][2]<upper_layer and coord2[i][2]>down_layer):
#            print("      0    0    0 ")
#        else:
#            print("      1    1    1 ")

def write_func(name2,lat2,coord2,natom2):
#    print the way input file aquires
    writethings=[]
    writethings.append("CELL_PARAMETERS {alat}\n")
    for i_cell_par in range(0,3):
        str="   "
        for j_cell_par in range(0,3):
            str+="%.10f"%lat2[i_cell_par][j_cell_par]
            str+="      "
        writethings.append(str+'\n')
        str=""
    writethings.append("ATOMIC_POSITIONS (crystal)\n")
    for i in range(natom2):
        if split_sybol_virtual in name2[i]:
            mixed_ele_spe=[]
            element_i_s=[x for x in name2[i].split(split_sybol_virtual) if len(x)>0]
            for jj in element_i_s:
                if (element_i_s.index(jj) % 2) == 0:
                    mixed_ele_spe.append(jj)
            str1="" 
            str1="%s      %.9f     %.9f      %.9f "%((mixed_ele_spe[0]+mixed_ele_spe[1]),coord2[i][0],coord2[i][1],coord2[i][2])
        else:
            str1="" 
            #str1="%s      %.9f     %.9f      %.9f "%(name2[i].replace(".",split_sybol_virtual),coord2[i][0],coord2[i][1],coord2[i][2])
            str1="%s      %.9f     %.9f      %.9f "%(name2[i],coord2[i][0],coord2[i][1],coord2[i][2])
        if ((mode=="surf")|(mode=="relax"))&(fixed_atom_mode==1):
            if(coord2[i][2]<upper_layer and coord2[i][2]>down_layer) or i in [x-1 for x in fixed_atom_index]:
                str1+="      0    0    0 "
            else:
                str1+="      1    1    1 "
        writethings.append(str1+'\n')
#   print(writethings)
    return writethings


def file_create_func(ina,name1,lat1,coord1,natom1,name_set1):
    error=0
    raws_1=[]
    raws2=[]
    mark=0
    mark_kpoints=0
    gamma_k=0
    molecule_i=''
    if ina != 'SIG':
        file_name=molecule+cnct_syb+str(ina)
        fnm=export_input_file+cnct_syb+str(ina)
        molecule_i=molecule+cnct_syb+str(ina)
    if ina == 'SIG':
        file_name=molecule
        fnm=export_input_file
        molecule_i=molecule
    isExists = os.path.exists(file_name)
    if isExists:
        os.chdir("%s/%s" %(dir,file_name)) 
        if os.path.isfile("delete_me_rm_file")==1:
            print("you must have done the scf or other calculation")
            os.chdir("/%s"%dir)
        else:
            os.chdir("/%s"%dir)
            os.system("rm -rf %s" %file_name)
            time.sleep(2)
            os.system("mkdir %s"%file_name)
            os.mknod("delete_me_rm_file")
            os.system("mv delete_me_rm_file %s"%file_name)          
    else: 
        os.system("mkdir %s"%file_name)
        os.mknod("delete_me_rm_file")
        os.system("mv delete_me_rm_file %s"%file_name)
    if os.path.isfile(fnm) == True:
        os.system("rm "+fnm)       
        time.sleep(1)
    os.mknod(fnm)                                #input_file_modify
    f1=open(input_cont,"r+")
    if (mode!="pdos")&(mode!="BaderCharge"):
        if os.path.isfile(mode_name):
            pass
        else:
            print(f"No {mode_name} found! Do you want to use default settings to do {mode}? Y/y for Yes, else for No")
            get_sig=input(">>>")
            if get_sig.lower()=='y':
                if os.path.isfile(f"{code_dir}/{mode_name}"):
                    print(f"cp {code_dir}/{mode_name} .")
                    os.system(f"cp {code_dir}/{mode_name} .")
                else:
                    print(f"No {mode_name} found in {code_dir}, manually copy to current dir!")
                    sys.exit(0)
            else:
                print(f"No {mode_name} found, manually copy to current dir!")
                sys.exit(0)
        f2=open(mode_name,"r+")
        raws2=f2.readlines()
#modify the input files
    if (mode=="pdos")|(mode=="BaderCharge"):
        if (os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0)&(os.path.isfile("%s/out_relax_%s"%(molecule_i,molecule_i))==0):
            error=1
            print(f"!!!ERROR:No scf has done before!plz do a scf before {mode} calculation!")
            return error
        else:
            f_make_pdos=open(fnm,"w")
            if mode=="pdos":
                input_postprocess=[
                "&PROJWFC\n",
                f"  prefix = \'{prefix}\',\n",
                "  outdir = \'./\',\n",
                "  ngauss = 0,\n",
                "  degauss = 0.01,\n",
                "/\n"
                ]
            elif mode=="BaderCharge":
                input_postprocess=[
                "&INPUTPP\n",
                f"  prefix = \'{prefix}\',\n",
                "  outdir = \'./\',\n",
                f"  filplot = \'Bader_{molecule}\',\n",
                "  plot_num = 0,\n",
                "/\n"
                "&PLOT\n",
                "  nfile = 1,\n",
                "  iflag = 3,\n",
                "  output_format = 6,\n",
                f"  fileout = \'Bader_{molecule}.cube\',\n",
                "/\n"
                ]

            for i in input_postprocess:
                f_make_pdos.writelines(i) 
            f_make_pdos.close()
            os.system("mv %s %s"%(fnm,file_name))
    elif (mode!="pdos")&(mode!="BaderCharge"):
        ##spin modify code
        if os.path.isfile(spin_file):
            for i,lines in enumerate(raws2):
                if "nspin" in lines:
                    if "2" in lines:
                        pass
                    if "4" in lines:
                        raise ValueError("This autoscript is only for spin=2, plz delete the SPIN and set the spin manually!")
                    if "1" in lines:
                        raws2.remove(raws2[i])
                        spin_line_reset=1

            for i,lines in enumerate(raws2[::-1]): # clear the former starting_set  python.remove() has some problem with a for loop :https://blog.csdn.net/m0_46521785/article/details/111303860
                if "nspin" in lines:
                    raws2.remove(lines)
                elif "starting_magnetization" in lines:
                    raws2.remove(lines)
            spin_input_lines=[]
            spin_input_lines.append("    nspin = 2,\n")
            spin_file_line=open(spin_file).readlines()
            for i,lines in enumerate(spin_file_line):
                if "#" in lines:
                    pass
                else:
                    spin_ele=[x for x in lines.strip("\n").split() if len(x)>0]
                    if spin_ele[0] in name_set1:
                        spin_index=name_set1.index(spin_ele[0])+1
                        spin_input_lines.append(f"    starting_magnetization({spin_index})={spin_ele[1]},\n")
                    #else:
                    #    print(f"{spin_ele[0]} not in {name_set1}")

        elif not os.path.isfile(spin_file):
            for i,lines in enumerate(raws2[::-1]): # clear the former starting_set  python.remove() has some problem with a for loop :https://blog.csdn.net/m0_46521785/article/details/111303860
                if "nspin" in lines:
                    raws2.remove(lines)
                elif "starting_magnetization" in lines:
                    raws2.remove(lines)

        ##dft+u modify code
        if os.path.isfile(dftu_file):
            for i,lines in enumerate(raws2):
                if "lda_plus_u_kind" in lines:
                    if "0" in lines:
                        pass
                    else:
                        raise ValueError("This autoscript is only for lda_plu_u=0, plz delete the DFT-U and set the dft+u manually!")

            for lines in raws2[::-1]: # clear the former lda_plus_u_set
                if lines.find("Hubbard_U")!=-1:
                    raws2.remove(lines)
                elif lines.find("lda_plus_u")!=-1:
                    raws2.remove(lines)
            dftu_input_lines=[]
            dftu_input_lines.append("    lda_plus_u = .true.\n")
            dftu_input_lines.append("    lda_plus_u_kind = 0\n")
            dftu_file_line=open(dftu_file).readlines()
            for i,lines in enumerate(dftu_file_line):
                if "#" in lines:
                    pass
                else:
                    dftu_ele=[x for x in lines.strip("\n").split() if len(x)>0]
                    if dftu_ele[0] in name_set1:
                        dftu_index=name_set1.index(dftu_ele[0])+1
                        dftu_input_lines.append(f"    Hubbard_U({dftu_index})={dftu_ele[1]},\n")
                    #else:
                        #print(f"{dftu_ele[0]} not in {name_set1}")
        if not os.path.isfile(dftu_file):
            for lines in raws2[::-1]: # clear the former lda_plus_u_set
                if lines.find("Hubbard_U")!=-1:
                    raws2.remove(lines)
                elif lines.find("lda_plus_u")!=-1:
                    raws2.remove(lines)

        for i in range(len(raws2)):
            if raws2[i].find('ATOMIC_SPECIES')!= -1:
                mark=i
            if raws2[i].find('K_POINTS')!= -1:
                if raws2[i].find("amma")!= -1:
                    gamma_k=1
                mark_kpoints=i
        if mark == 0:
            print("file not found")
        raws_1=raws2[:mark]
        ##found the insert point 
        input_index_spin_ldau=0
        for i,lines in enumerate(raws_1):
            if "ecutwfc" in lines:
                input_index_spin_ldau=i+1
        if input_index_spin_ldau==0:
            raise ValueError("No ecutwfc found in input, plz specify the ecutwfc")
        #insert the spin and ldau into input file
        if os.path.isfile(spin_file):
            for lines in spin_input_lines[::-1]:
                raws_1.insert(input_index_spin_ldau,lines)
                #print(lines)
        if os.path.isfile(dftu_file):
            for lines in dftu_input_lines[::-1]:
                raws_1.insert(input_index_spin_ldau,lines)
                #print(lines)
        ntyp_index=0
        find_nat=0
        for i in range(len(raws_1)):
            if raws_1[i].find("nat=")!=-1:
                raws_1[i]="    nat=  %d,\n"%natom1
                find_nat=1
            if raws_1[i].find("ntyp=")!=-1:
                raws_1[i]="    ntyp= %d,\n"%len(name_set1)
                ntyp_index=i
                #print(ntyp_index)
        if find_nat==0:
            print("!!!ERROR,not nat= found!")
            error=1
            return error
        if mode=="bands":
            if (os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0)&(os.path.isfile("%s/out_relax_%s"%(molecule_i,molecule_i))==0): 
                error=1
                print("!!!ERROR:No scf has done before!plz do a scf before bands calculation!")
                return error
            find_nbnd=0
            find_nbnd_index=0
            for raws_input in raws_1:
                #print(raws_input)
                if raws_input.find("nbnd")!=-1:
                    find_nbnd=1
                    find_nbnd_index=raws_1.index(raws_input)
                    #print("!!!!nbnd found")
            if os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==1:
                bands_num=bands_read("%s/out_scf_%s"%(molecule_i,molecule_i))
            elif os.path.isfile("%s/out_scf_%s"%(molecule_i,molecule_i))==0:
                bands_num=bands_read("%s/out_relax_%s"%(molecule_i,molecule_i))
            if bands_num==0:
                error=1
                print("Something is wrong with bands in you scf output file!")
                return error
            if find_nbnd==1:
                raws_1[find_nbnd_index]="    nbnd= %d,\n"%bands_num
            elif find_nbnd==0:
                raws_1.insert(ntyp_index,"    nbnd= %d,\n"%bands_num)
        raws_1.append("ATOMIC_SPECIES\n")
        SP=[]
        for i in range(len(name_set1)):
            SP.append(psp_form(name_set1[i]))
            if split_sybol_virtual in name_set1[i]:
                mixed_ele_spe=[]
                element_i_s=[x for x in name_set1[i].split(split_sybol_virtual) if len(x)>0]
                for jj in element_i_s:
                    if (element_i_s.index(jj) % 2) == 0:
                        mixed_ele_spe.append(jj)
                raws_1.append("%3s  %6.2f   %s\n"%((mixed_ele_spe[0]+mixed_ele_spe[1]),rl_aw(name_set1[i]),SP[i]))
            else:
                #raws_1.append("%3s  %6.2f   %s\n"%(name_set1[i].replace(".",split_sybol_virtual),rl_aw(name_set1[i]),SP[i]))
                raws_1.append("%3s  %6.2f   %s\n"%(name_set1[i],rl_aw(name_set1[i]),SP[i]))
    
        #K_Points_modify
        raws_1.append(raws2[mark_kpoints])
        if gamma_k==0:
            kpoint_type=raws2[mark_kpoints+1].split(" ")
            kpoint_type_len=[]
            for i in kpoint_type:
                if (len(i)>0)&(i!="\n"):
                    kpoint_type_len.append(i)
            #print("************************************",kpoint_type_len)
            if len(kpoint_type_len)>1:       #more than one number in k point,aka a normal kpoint sample
                if k_points_auto_mod==1:

                    def get_vector_lengths(matrix):
                      """
                      计算 3x3 矩阵的三个矢量 a、b、c 的模长。
                    
                      Args:
                        matrix: 一个 3x3 矩阵。
                    
                      Returns:
                        一个包含三个模长的列表。
                      """
                    
                      a_x, a_y, a_z = matrix[0, :]
                      b_x, b_y, b_z = matrix[1, :]
                      c_x, c_y, c_z = matrix[2, :]
                    
                      a_length = math.sqrt(a_x**2 + a_y**2 + a_z**2)
                      b_length = math.sqrt(b_x**2 + b_y**2 + b_z**2)
                      c_length = math.sqrt(c_x**2 + c_y**2 + c_z**2)
                    
                      return [a_length, b_length, c_length]

                    ax,by,cz=get_vector_lengths(lat1)

                    def get_kx(a):
                        """
                        根据输入的 a 定义 kx 值。
                      
                        Args:
                          a: 输入值。
                      
                        Returns:
                          kx 值。
                        """
                        if a==0:
                            return 1
                        # 计算 a * kx 的范围。
                        min_value = 20
                        max_value = 30
                        # 找到最小的 kx 整数值，使得 a * kx 在范围内。
                        kx = 1
                        while a * kx < min_value:
                          kx += 1
                        # 如果没有 kx 可以使 a * kx 在范围内，则 kx 取 1。
                        if a * kx > max_value:
                          kx = 1
                      
                        return kx
                    raws_1.append(f" {get_kx(ax)}  {get_kx(by)}  {get_kx(cz)}  0  0  0\n")
                                      
                else:
                    raws_1.append(raws2[mark_kpoints+1])
            elif len(kpoint_type_len)==1: #only one number in first line in k point, aka k-path sample
                for n in range(mark_kpoints+1,mark_kpoints+1+int(kpoint_type_len[0])+1):
                    raws_1.append(raws2[n])

        for i in range(len(raws_1)):
            f3=open(fnm,"a")
            f3.write(raws_1[i])
            f3.close()
        f4=open(fnm,"a+")
        f4.writelines(write_func(name1,lat1,coord1,natom1))
        os.system("mv %s %s"%(fnm,file_name))
    
    
        if solvation_model==1:
        #Environ file cp
            if os.path.isfile("./environ.in")==1:
                os.system("cp environ.in %s"%file_name)
                print("environ file found!")
            else:
                error=1
                print("!!!ERROR:environ.in file needed!")
                return error
        for i in range(len(SP)):
            if os.path.isfile(SP[i])==1:
                print("%s founded!"%SP[i])
                os.system("cp %s %s" %(SP[i],file_name))
            elif os.path.exists(psp_dir_root):
                print("copy from root dir %s"%SP[i])
                os.system("cp %s/%s %s" %(psp_dir(name_set1[i])[0],SP[i],file_name))
            elif os.path.exists(psp_dir_backup):
                print("copy from backup dir %s"%SP[i])
                os.system("cp %s/%s %s" %(psp_dir(name_set1[i])[1],SP[i],file_name))
            else:
                raise ValueError(f"No psp dir found in root dir:{psp_dir_root} or backup dir:{psp_dir_backup}")
#modify job and sub job
    if bcon_mode==1:
        print("python {code_dir}/bcon.py mode on!")
        out_file_test=''
        out_file_test='out_'+mode+'_'+molecule_i
        if os.path.isfile(out_file_test)==1:
            print("replace the outfile into infile")
            #print("python {code_dir}/bcon.py out_%s_%s in_%s_%s"%(mode,molecule_i,mode,molecule_i))
            os.system("python {code_dir}/bcon.py out_%s_%s in_%s_%s"%(mode,molecule_i,mode,molecule_i))

    if (sub_script==1)&(error==0):         
        os.chdir("%s/%s" %(dir,file_name)) 
        type_hpc_out=os.popen(f"python {code_dir}/create_job_script.py {file_name} {mode}").readline().strip("\n").strip().split("###")[-1]
        if type_hpc_out=="slurm":
            os.system("sbatch %s"%JOB)
        if type_hpc_out=="pbs":
            os.system("qsub %s" %JOB)                             #change it with your HCP
        os.chdir("/%s"%dir)
    if (sub_script==0)&(error==0):         
        os.chdir("%s/%s" %(dir,file_name)) 
        type_hpc_out=os.popen(f"python {code_dir}/create_job_script.py {file_name} {mode}").readline().strip("\n").strip().split("###")[-1]
        os.chdir("/%s"%dir)
    time.sleep(1)
    return error

#print("batchmode:%s"%batch_mode)




if (batch_mode==1) & (error==0):
    #print("batchmode 1")
    for i in range(file_min,file_max+1):

        input_cont=molecule+cnct_syb+str(i)+input2
        print(input_cont+' searching...')
        name1=[]
        lat1=[]
        coord1=[]
        natom=0
        name_set1=[]
        if os.path.isfile(input_cont) == True:
            name1,lat1,coord1,natom1,name_set1=read_vasp_single_file(input_cont)
            error=file_create_func(i,name1,lat1,coord1,natom1,name_set1)  
            print("%s is detected!"%input_cont)
        else:
            error=1
            print("%s is not exsist"%input_cont)

elif (batch_mode == 0) & (error==0):
    #print("batchmode 0")
    input_cont=molecule+input2
    print(input_cont+' searching...')
    name2=[]
    lat2=[]
    coord2=[]
    natom2=0
    name_set2=[]
    if os.path.isfile(input_cont) == True:
        name2,lat2,coord2,natom2,name_set2=read_vasp_single_file(input_cont)
        error=file_create_func("SIG",name2,lat2,coord2,natom2,name_set2)
        print("%s is detected!"%input_cont)
    else:
        error=1
        print("%s is not exsist"%input_cont)
#print("error is ",error)
if error==0:
    file_name=vaspfile.split(".vasp")[0]
    type_hpc_out=os.popen(f"python {code_dir}/create_job_script.py {file_name} {mode} -c").readline().strip("\n").strip().split("###")[-1]
    print(type_hpc_out)
    if sub_script==1:
        if type_hpc_out=="pbs":
            os.system("qstat")                                           #change it with your HCP
        elif type_hpc_out=="slurm":
            os.system("squeue")
    else:
        print("JOB not submit, change sub_script to 1 in replace.py")
    print("Congradulations,your time was saved by automatic script!")
if error==1:
    print("An error occur!")
